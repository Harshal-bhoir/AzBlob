"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const QPState_1 = tslib_1.__importDefault(require("./QPState"));
const QueryStateName_1 = require("./QueryStateName");
class StatePredicateStarted extends QPState_1.default {
    constructor() {
        super(...arguments);
        this.name = QueryStateName_1.QueryStateName.PredicateStarted;
        /**
         * Starts the processing of a predicate clause
         * these ar the units in which we need to maintain
         * backwards schema compatibility
         *
         * @param {QueryContext} context
         * @memberof StatePredicateStarted
         */
        this.onProcess = (context) => {
            let token = "";
            [context, token] = this.getNextToken(context);
            context = this.handleToken(context, token);
            return context;
        };
        /**
         * optional post processing, here we can add logging
         * or additional validation etc
         *
         * @param {QueryContext} context
         * @memberof StateProcessValue
         */
        this.onExit = (context) => {
            return context;
        };
    }
    /**
     * state transition logic
     *
     * @protected
     * @param {QueryContext} context
     * @param {string} token
     * @return {*}  {QueryContext}
     * @memberof StatePredicateStarted
     */
    handleToken(context, token) {
        // categorize the token
        if (token === "") {
            context.stateQueue.push(QueryStateName_1.QueryStateName.PredicateFinished);
        }
        else if (token === "(") {
            context.stateQueue.push(QueryStateName_1.QueryStateName.ProcessParensOpen);
        }
        else if (token === ")") {
            context.stateQueue.push(QueryStateName_1.QueryStateName.ProcessParensClose);
        }
        else if (this.isPredicateOperator(token)) {
            this.presdicateStartingOperator(context);
        }
        else if (this.isOperand(token)) {
            // match operand (specific set)
            throw new Error("Invalid Query, cannot start predicate with operator! " + token);
        }
        else if (this.isValue(token)) {
            // match number (long & doubles? needed)
            // match string (starts with ', or " ?)
            // match guid (is exactly guid'<guidval>')
            context.stateQueue.push(QueryStateName_1.QueryStateName.ProcessValue);
        }
        else if (this.isIdentifier(token)) {
            // match identifier (can only start with letter)
            context.stateQueue.push(QueryStateName_1.QueryStateName.ProcessIdentifier);
        }
        return context;
    }
    /**
     * There are 2 cases that will get us here:
     * 1. a filter without parens
     * - we will have processed a predicate
     * - we should finish the predicate
     * 2. a not operator on it's own
     * - we will not have processed a value or identifier
     * - we must process the operator
     * - will need to end current predicate and create a new predicate
     *
     * @private
     * @param {QueryContext} context
     * @memberof StatePredicateStarted
     */
    presdicateStartingOperator(context) {
        if (context.currentPos === 0 ||
            context.taggedPredicates[context.currentPredicate].tokenMap.tokens ===
                undefined ||
            context.taggedPredicates[context.currentPredicate].tokenMap.tokens
                .length === 0) {
            context.stateQueue.push(QueryStateName_1.QueryStateName.ProcessOperator);
        }
        else {
            context.stateQueue.push(QueryStateName_1.QueryStateName.PredicateFinished);
        }
    }
}
exports.default = StatePredicateStarted;
//# sourceMappingURL=StatePredicateStarted.js.map