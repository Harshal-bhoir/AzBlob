"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const IdentifierToken_1 = tslib_1.__importDefault(require("../TokenModel/IdentifierToken"));
const TaggedToken_1 = tslib_1.__importDefault(require("../TokenModel/TaggedToken"));
const ValueToken_1 = tslib_1.__importDefault(require("../TokenModel/ValueToken"));
class BinaryPredicate {
    constructor(tokenMap) {
        this.tokenMap = tokenMap;
    }
    /**
     * Converts a binary predicate for LokiJs filter
     *
     * @return {*}
     * @memberof BinaryPredicate
     */
    convertPredicateForLokiJS() {
        const newTokens = [];
        try {
            this.tokenMap.tokens.forEach((taggedToken) => {
                this.pushValue(taggedToken, newTokens);
                this.pushIdentifier(taggedToken, newTokens);
                this.pushOperator(taggedToken, newTokens);
            });
            this.tokenMap.tokens = newTokens;
        }
        catch (err) {
            throw err;
        }
        return this;
    }
    /**
     * Pushes value for boolean predicate
     *
     * @param {TaggedToken} taggedToken
     * @param {TaggedToken[]} newTokens
     * @memberof BooleanPredicate
     */
    pushValue(taggedToken, newTokens) {
        if (taggedToken.type.isValue()) {
            // assumption is that we have a binary value which needs to be
            // converted to base64
            // decision on type is made earlier so no additional check
            const trim = this.getTrimLength(taggedToken.token);
            const binaryString = taggedToken.token.slice(trim, taggedToken.token.length - 1);
            const base64String = Buffer.from(binaryString, "hex").toString("base64");
            newTokens.push(new TaggedToken_1.default("'" + base64String + "'", new ValueToken_1.default()));
        }
    }
    getTrimLength(token) {
        if (token.match(/^X\'/) !== null) {
            return 2;
        }
        else if (token.match(/^binary\'/) !== null) {
            return 7;
        }
        return 0;
    }
    /**
     * pushes identifier for boolean predicate
     *
     * @param {TaggedToken} taggedToken
     * @param {TaggedToken[]} newTokens
     * @memberof BooleanPredicate
     */
    pushIdentifier(taggedToken, newTokens) {
        if (taggedToken.type.isIdentifier()) {
            newTokens.push(new TaggedToken_1.default(`item.properties.${taggedToken.token}`, new IdentifierToken_1.default()));
        }
    }
    /**
     * pushes operator for boolean predicate
     *
     * @param {TaggedToken} taggedToken
     * @param {TaggedToken[]} newTokens
     * @memberof BooleanPredicate
     */
    pushOperator(taggedToken, newTokens) {
        if (taggedToken.type.isOperator()) {
            newTokens.push(taggedToken);
        }
    }
}
exports.default = BinaryPredicate;
//# sourceMappingURL=BinaryPredicate.js.map