"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const QueryStateName_1 = require("./QueryStateName");
const TokenMap_1 = require("./PredicateModel/TokenMap");
const TaggedToken_1 = tslib_1.__importDefault(require("./TokenModel/TaggedToken"));
const ParensOpenToken_1 = tslib_1.__importDefault(require("./TokenModel/ParensOpenToken"));
const ParensCloseToken_1 = tslib_1.__importDefault(require("./TokenModel/ParensCloseToken"));
const ParensClose_1 = tslib_1.__importDefault(require("./PredicateModel/ParensClose"));
const ParensOpen_1 = tslib_1.__importDefault(require("./PredicateModel/ParensOpen"));
const UnknownPredicate_1 = tslib_1.__importDefault(require("./PredicateModel/UnknownPredicate"));
const PredicateOperator_1 = tslib_1.__importDefault(require("./PredicateModel/PredicateOperator"));
class QPState {
    constructor() {
        this.name = QueryStateName_1.QueryStateName.None;
    }
    onProcess(context) {
        return context;
    }
    onExit(context) {
        return context;
    }
    /**
     * Processes the first opening parens of a query
     * @param context
     * @returns
     */
    processOpeningParens(context, token) {
        if (token.match(/\(/) && context.currentPos === 0) {
            const taggedToken = new TaggedToken_1.default("(", new ParensOpenToken_1.default());
            context.taggedPredicates.push(new ParensOpen_1.default(new TokenMap_1.TokenMap([taggedToken])));
            context.currentPos += 1;
        }
        return context;
    }
    /**
     * Processes the closing parens on a query
     * @param context
     * @returns
     */
    processClosingParens(context) {
        if (context.originalQuery.match(/^\)/)) {
            const taggedToken = new TaggedToken_1.default(")", new ParensCloseToken_1.default());
            context.taggedPredicates.push(new ParensClose_1.default(new TokenMap_1.TokenMap([taggedToken])));
            context.currentPos += 1;
        }
        return context;
    }
    startofNextRelevantToken(context) {
        let pos = context.currentPos;
        let token = context.originalQuery[pos];
        let relevantTokenFound = false;
        while (relevantTokenFound === false && pos < context.originalQuery.length) {
            token = context.originalQuery[pos];
            switch (token) {
                case " ":
                    pos += 1;
                    context.currentPos += 1;
                    break;
                default:
                    relevantTokenFound = true;
                    break;
            }
        }
        return [context, pos];
    }
    endOfToken(context, startPos) {
        if (context.originalQuery[startPos] === "(" ||
            context.originalQuery[startPos] === ")") {
            return startPos + 1;
        }
        let pos = startPos + 1;
        let token = context.originalQuery[pos];
        let endTokenFound = false;
        while (endTokenFound === false && pos < context.originalQuery.length) {
            token = context.originalQuery[pos];
            switch (token) {
                case " ":
                    endTokenFound = true;
                    break;
                case "(":
                    endTokenFound = true;
                    break;
                case ")":
                    endTokenFound = true;
                    break;
                default:
                    pos += 1;
                    break;
            }
        }
        if (pos > context.originalQuery.length) {
            return context.originalQuery.length - 1;
        }
        return pos;
    }
    /**
     * Determines the next token.
     * @param context
     * @returns
     */
    getNextToken(context) {
        // detmermine what the next token should be.
        // logic:
        // from current position in query string
        // determine start if token:
        let tokenStart;
        [context, tokenStart] = this.startofNextRelevantToken(context);
        // determine end:
        const tokenEnd = this.endOfToken(context, tokenStart);
        return this.validateToken(context, tokenStart, tokenEnd);
    }
    validateToken(context, tokenStart, tokenEnd) {
        if (tokenEnd > context.originalQuery.length) {
            return [context, ""];
        }
        return [context, context.originalQuery.slice(tokenStart, tokenEnd)];
    }
    isPredicateOperator(token) {
        let isOperator = true;
        switch (token) {
            case "and":
                break;
            case "or":
                break;
            case "not":
                break;
            default:
                isOperator = false;
        }
        return isOperator;
    }
    /**
     * checks if the token matches what should be a value
     * Does not validate that the value is using correct
     * Syntax!
     *
     * @param {string} token
     * @return {*}  {boolean}
     * @memberof QPState
     */
    isValue(token) {
        // Is the syntax for other EDM types case sensitive?
        const match = token.match(/^true$|^false$|^-?\d+|^guid'|^'|^"|^X'|^binary'|^datetime'/i);
        if (match !== null && match.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Checks is value matches correct Guid syntax
     *
     * @param {string} token
     * @return {boolean}
     * @memberof QPState
     */
    isGuidValue(token) {
        const match = token.match(/^guid'[A-Z0-9]{8}-([A-Z0-9]{4}-){3}[A-Z0-9]{12}'/gim);
        if (match !== null && match.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Checks if token matches binary syntax
     *
     * @param {string} token
     * @return {*}  {boolean}
     * @memberof QPState
     */
    isBinaryValue(token) {
        const match = token.match(/^X'|^binary'/);
        if (match !== null && match.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Checks if token matches Long value syntax
     *
     * @param {string} token
     * @return {*}  {boolean}
     * @memberof QPState
     */
    isLongValue(token) {
        const match = token.match(/^-?\d+\.?\d*L$/);
        if (match !== null && match.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Checks if token matches integer value syntax
     *
     * @param {string} token
     * @return {*}  {boolean}
     * @memberof QPState
     */
    isIntegerValue(token) {
        const match = token.match(/^-?\d+$/);
        if (match !== null && match.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Checks if token matches string value syntax
     *
     * @param {string} token
     * @return {*}  {boolean}
     * @memberof QPState
     */
    isStringValue(token) {
        const match = token.match(/^\'.*\'$|^\".*\"$/);
        if (match !== null && match.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Checks if token matches Long value syntax
     *
     * @param {string} token
     * @return {*}  {boolean}
     * @memberof QPState
     */
    isDoubleValue(token) {
        const match = token.match(/^-?\d+\.+\d+$/);
        if (match !== null && match.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Checks if token matches datetime value syntax
     *
     * @param {string} token
     * @return {*}  {boolean}
     * @memberof QPState
     */
    isDateValue(token) {
        const match = token.match(/^datetime'/);
        if (match !== null && match.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Checks if token matches boolean value syntax
     *
     * @param {string} token
     * @return {*}  {boolean}
     * @memberof QPState
     */
    isBooleanValue(token) {
        const match = token.match(/^true$|^false$/i);
        if (match !== null && match.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Checks if token is an identifier
     *
     * @param {string} token
     * @return {*}  {boolean}
     * @memberof QPState
     */
    isIdentifier(token) {
        const match = token.match(/^(?!true$)(?!false$)(?!guid')(?!binary')(?!X')(?!datetime')[_a-zA-Z]/i);
        if (match !== null && match.length > 0) {
            return true;
        }
        return false;
    }
    isOperand(token) {
        // ToDo: Validate performance vs regex or array / enum op
        let isOperator = true;
        switch (token) {
            case "eq":
                break;
            case "gt":
                break;
            case "ge":
                break;
            case "lt":
                break;
            case "le":
                break;
            case "ne":
                break;
            default:
                isOperator = false;
        }
        return isOperator;
    }
    updateTaggedTokens(context, taggedToken) {
        let taggedTokens = [];
        if (context.taggedPredicates.length === context.currentPredicate + 1) {
            taggedTokens =
                context.taggedPredicates[context.currentPredicate].tokenMap.tokens;
        }
        taggedTokens.push(taggedToken);
        return taggedTokens;
    }
    /**
     * Updates tagged predicate, will set to unknown
     * PredicateType should be set correctly in the checking functions
     *
     * @protected
     * @param {TaggedToken[]} taggedTokens
     * @param {QueryContext} context
     * @return {*}  {QueryContext}
     * @memberof QPState
     */
    updateTaggedPredicate(taggedTokens, context, isPredicateOperator = false) {
        const tokenMap = new TokenMap_1.TokenMap(taggedTokens);
        context.taggedPredicates[context.currentPredicate] = isPredicateOperator
            ? new PredicateOperator_1.default(tokenMap)
            : new UnknownPredicate_1.default(tokenMap);
        return context;
    }
}
exports.default = QPState;
//# sourceMappingURL=QPState.js.map