"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const TaggedToken_1 = tslib_1.__importDefault(require("../TokenModel/TaggedToken"));
const IdentifierToken_1 = tslib_1.__importDefault(require("../TokenModel/IdentifierToken"));
const ValueToken_1 = tslib_1.__importDefault(require("../TokenModel/ValueToken"));
class StringPredicate {
    constructor(tokenMap) {
        this.tokenMap = tokenMap;
    }
    /**
     * converts a string predicate for lokijs schema
     *
     * @return {*}
     * @memberof StringPredicate
     */
    convertPredicateForLokiJS() {
        const newTokens = [];
        this.tokenMap.tokens.forEach((taggedToken) => {
            this.pushValue(taggedToken, newTokens);
            this.pushIdentifier(taggedToken, newTokens);
            this.pushOperator(taggedToken, newTokens);
        });
        this.tokenMap.tokens = newTokens;
        return this;
    }
    /**
     * Pushes the value to the string predicate
     *
     * @private
     * @param {TaggedToken} taggedToken
     * @param {TaggedToken[]} newTokens
     * @memberof StringPredicate
     */
    pushValue(taggedToken, newTokens) {
        if (taggedToken.type.isValue()) {
            taggedToken.token =
                "'" +
                    // We also need to convert any double apostrophes into their corresponding backslash-escaped variant
                    this.replaceDoubleApostrophes(
                    // Let's ensure that backslashes (which are valid characters in the OData space) are escaped correctly.
                    this.escapeReservedCharacters(taggedToken.token.substring(1, taggedToken.token.length - 1))) +
                    "'";
            newTokens.push(new TaggedToken_1.default(taggedToken.token, new ValueToken_1.default()));
        }
    }
    /**
     * Ensure that the presence of a '' in the string is converted into the explicit ' (apostrophe) character.
     *
     * @param {string} token
     * @memberof StringPredicate
     * @returns {string}
     */
    replaceDoubleApostrophes(token) {
        return token.replace(/(\'\')/g, "\\'");
    }
    /**
     * Ensures that backticks (which are used to encode the string)
     *
     * @param {string} token
     * @memberof StringPredicate
     * @returns {string}
     */
    escapeReservedCharacters(token) {
        return token.replace(/\\/g, "\\\\");
    }
    /**
     * Pushes the identifier to the string predicate
     *
     * @private
     * @param {TaggedToken} taggedToken
     * @param {TaggedToken[]} newTokens
     * @memberof StringPredicate
     */
    pushIdentifier(taggedToken, newTokens) {
        if (taggedToken.type.isIdentifier()) {
            const newToken = this.createStringIdentifierToken(taggedToken.token);
            newTokens.push(newToken);
        }
    }
    /**
     * handles the special case for "TableName"
     *
     * @param {string} token
     * @return {*}
     * @memberof StringPredicate
     */
    createStringIdentifierToken(token) {
        // asterisk is not allowed in an identifier
        if (token.toLocaleLowerCase() === "**blena**") {
            return new TaggedToken_1.default(`item.table`, new IdentifierToken_1.default());
        }
        return new TaggedToken_1.default(`item.properties.${token}`, new IdentifierToken_1.default());
    }
    /**
     * Pushes the operator to the string predicate
     *
     * @private
     * @param {TaggedToken} taggedToken
     * @param {TaggedToken[]} newTokens
     * @memberof StringPredicate
     */
    pushOperator(taggedToken, newTokens) {
        if (taggedToken.type.isOperator()) {
            newTokens.push(taggedToken);
        }
    }
}
exports.default = StringPredicate;
//# sourceMappingURL=StringPredicate.js.map