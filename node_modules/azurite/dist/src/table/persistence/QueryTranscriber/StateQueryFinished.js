"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const QueryStateName_1 = require("./QueryStateName");
/**
 * state to complete the transcribing of a query
 *
 * @export
 * @class StateQueryFinished
 * @implements {IQPState}
 */
class StateQueryFinished {
    constructor() {
        this.name = QueryStateName_1.QueryStateName.QueryFinished;
        /**
         * completes query transcribing
         *
         * @memberof StateQueryFinished
         */
        this.onProcess = (context) => {
            // first setup the query output function
            context.transcribedQuery = "return (";
            // add tagged predicates to the query output, then close the query function
            // this is where we add support for backwards compatability in the schema
            // and do conversions for special types etc and their DB schema representation
            for (const taggedPredicate of context.taggedPredicates) {
                let predicate = "";
                if (taggedPredicate !== undefined) {
                    const convertedPredicate = taggedPredicate.convertPredicateForLokiJS();
                    for (const taggedPredicateToken of convertedPredicate.tokenMap.tokens) {
                        predicate += " ";
                        predicate += taggedPredicateToken.token;
                    }
                }
                context.transcribedQuery += predicate;
            }
            // Close off query function:
            context.transcribedQuery += " )";
            return context;
        };
        /**
         * optional post processing, here we can add logging
         * or additional validation etc
         *
         * @param {QueryContext} context
         * @memberof StateProcessValue
         */
        this.onExit = (context) => {
            // ToDo: Log converted query?
            return context;
        };
    }
}
exports.default = StateQueryFinished;
//# sourceMappingURL=StateQueryFinished.js.map