"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const TaggedToken_1 = tslib_1.__importDefault(require("../TokenModel/TaggedToken"));
const IdentifierToken_1 = tslib_1.__importDefault(require("../TokenModel/IdentifierToken"));
const OperatorToken_1 = tslib_1.__importDefault(require("../TokenModel/OperatorToken"));
const ParensCloseToken_1 = tslib_1.__importDefault(require("../TokenModel/ParensCloseToken"));
const ParensOpenToken_1 = tslib_1.__importDefault(require("../TokenModel/ParensOpenToken"));
const ValueToken_1 = tslib_1.__importDefault(require("../TokenModel/ValueToken"));
class GuidPredicate {
    constructor(tokenMap) {
        this.tokenMap = tokenMap;
    }
    /**
     * Converts a guid predicate for lokijs schema
     * Guid predicate has special handling as we need to support
     * older schema for the cases that database is not new before
     * updating to new logic to differentiate between guid type
     * and string type
     *
     * @return {*}
     * @memberof GuidPredicate
     */
    convertPredicateForLokiJS() {
        const newTokens = [];
        this.pushBase64GuidPredicate(newTokens, this.tokenMap);
        this.backWardCompatibleGuidMatch(newTokens, this.tokenMap);
        this.tokenMap.tokens = newTokens;
        return this;
    }
    /**
     * GUIDs were originally stored as plain strings, but this diverged from the
     * service, so we changed the storage format to base64 encoded strings.
     * To allow for transition between schemas, we update "equals / not equals"
     * queries to search for both plain string and base64 encoded.
     *
     * @param {TaggedToken[]} newTokens
     * @param {TokenMap} tokenMap
     * @memberof GuidPredicate
     */
    backWardCompatibleGuidMatch(newTokens, tokenMap) {
        if (this.isBackWardsCompatiblePredicate(tokenMap)) {
            this.pushPredicate(newTokens, this.tokenMap);
            this.pushStringGuidPredicate(newTokens, this.tokenMap);
        }
    }
    isBackWardsCompatiblePredicate(tokenMap) {
        return (tokenMap.tokens[1].token === "===" || tokenMap.tokens[1].token === "!==");
    }
    /**
     * adds an OR operator to allow query to return both base64 and string GUIDs
     * or an AND operator to retun GUIDs not matching either base64 or string rep
     * other operators cannot support backwards compatibility and require the
     * persistent storage (database) to be recreated
     *
     * @private
     * @param {TaggedToken[]} newTokens
     * @param {TokenMap} taggedPredicate
     * @memberof GuidPredicate
     */
    pushPredicate(newTokens, tokenMap) {
        if (tokenMap.tokens[1].token === "===") {
            newTokens.push(new TaggedToken_1.default("||", new OperatorToken_1.default()));
        }
        else {
            newTokens.push(new TaggedToken_1.default("&&", new OperatorToken_1.default()));
        }
    }
    /**
     * new schema converts guids to base64 representation
     *
     * @private
     * @param {TaggedToken[]} newTokens
     * @param {TokenMap} taggedPredicate
     * @memberof GuidPredicate
     */
    pushBase64GuidPredicate(newTokens, taggedPredicate) {
        if (this.isBackWardsCompatiblePredicate(taggedPredicate)) {
            newTokens.push(new TaggedToken_1.default("(", new ParensOpenToken_1.default()));
        }
        taggedPredicate.tokens.forEach((taggedToken) => {
            this.pushIdentifier(taggedToken, newTokens);
            this.pushOperator(taggedToken, newTokens);
            this.pushBase64Guid(taggedToken, newTokens);
        });
        if (this.isBackWardsCompatiblePredicate(taggedPredicate)) {
            newTokens.push(new TaggedToken_1.default(")", new ParensCloseToken_1.default()));
        }
    }
    /**
     * Pushes the base64 guid to the predicate
     *
     * @private
     * @param {TaggedToken} taggedToken
     * @param {TaggedToken[]} newTokens
     * @memberof GuidPredicate
     */
    pushBase64Guid(taggedToken, newTokens) {
        if (taggedToken.type.isValue()) {
            const newToken = taggedToken.token.substring(5, taggedToken.token.length - 1);
            const guidBuff = Buffer.from(newToken);
            newTokens.push(new TaggedToken_1.default(`'${guidBuff.toString("base64")}'`, new ValueToken_1.default()));
        }
    }
    /**
     * old schema guids used string representation
     *
     * @private
     * @param {TaggedToken[]} newTokens
     * @param {TokenMap} taggedPredicate
     * @memberof GuidPredicate
     */
    pushStringGuidPredicate(newTokens, taggedPredicate) {
        newTokens.push(new TaggedToken_1.default("(", new ParensOpenToken_1.default()));
        taggedPredicate.tokens.forEach((taggedToken) => {
            this.pushStringGuid(taggedToken, newTokens);
            this.pushIdentifier(taggedToken, newTokens);
            this.pushOperator(taggedToken, newTokens);
        });
        newTokens.push(new TaggedToken_1.default(")", new ParensCloseToken_1.default()));
    }
    /**
     * Pushes the string guid to the predicate
     *
     * @private
     * @param {TaggedToken} taggedToken
     * @param {TaggedToken[]} newTokens
     * @memberof GuidPredicate
     */
    pushStringGuid(taggedToken, newTokens) {
        if (taggedToken.type.isValue()) {
            const newToken = taggedToken.token.substring(4);
            newTokens.push(new TaggedToken_1.default(newToken, new ValueToken_1.default()));
        }
    }
    /**
     * Pushes the guid identifier to the predicate
     *
     * @private
     * @param {TaggedToken} taggedToken
     * @param {TaggedToken[]} newTokens
     * @memberof GuidPredicate
     */
    pushIdentifier(taggedToken, newTokens) {
        if (taggedToken.type.isIdentifier()) {
            newTokens.push(new TaggedToken_1.default(`item.properties.${taggedToken.token}`, new IdentifierToken_1.default()));
        }
    }
    /**
     * Pushes the operator to the guid predicate
     *
     * @private
     * @param {TaggedToken} taggedToken
     * @param {TaggedToken[]} newTokens
     * @memberof GuidPredicate
     */
    pushOperator(taggedToken, newTokens) {
        if (taggedToken.type.isOperator()) {
            newTokens.push(taggedToken);
        }
    }
}
exports.default = GuidPredicate;
//# sourceMappingURL=GuidPredicate.js.map