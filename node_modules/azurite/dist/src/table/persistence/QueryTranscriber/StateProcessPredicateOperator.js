"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const QPState_1 = tslib_1.__importDefault(require("./QPState"));
const QueryStateName_1 = require("./QueryStateName");
const TaggedToken_1 = tslib_1.__importDefault(require("./TokenModel/TaggedToken"));
const OperatorToken_1 = tslib_1.__importDefault(require("./TokenModel/OperatorToken"));
const UnknownPredicate_1 = tslib_1.__importDefault(require("./PredicateModel/UnknownPredicate"));
const TokenMap_1 = require("./PredicateModel/TokenMap");
const PredicateOperator_1 = tslib_1.__importDefault(require("./PredicateModel/PredicateOperator"));
/**
 * contains the logic for handling operators between predicates
 *
 * @export
 * @class StateProcessPredicateOperator
 * @extends {QPState}
 * @implements {IQPState}
 */
class StateProcessPredicateOperator extends QPState_1.default {
    constructor() {
        super(...arguments);
        this.name = QueryStateName_1.QueryStateName.ProcessOperator;
        /**
         * process current query token which is operator
         *
         * @param {QueryContext} context
         * @memberof StateProcessOperator
         */
        this.onProcess = (context) => {
            let token = "";
            [context, token] = this.getNextToken(context);
            const originalTokenLength = token.length;
            token = this.convertOperatorToken(token);
            context = this.storeTaggedTokens(context, token, originalTokenLength);
            [context, token] = this.getNextToken(context);
            context = this.handleToken(context, token);
            return context;
        };
        /**
         * optional post processing, here we can add logging
         * or additional validation etc
         *
         * @param {QueryContext} context
         * @memberof StateProcessValue
         */
        this.onExit = (context) => {
            return context;
        };
    }
    /**
     * contains state transition logic
     *
     * @protected
     * @param {QueryContext} context
     * @param {string} token
     * @return {*}  {QueryContext}
     * @memberof StateProcessPredicateOperator
     */
    handleToken(context, token) {
        // with a predicate operator we always finish the last predicate and start another
        context.stateQueue.push(QueryStateName_1.QueryStateName.PredicateFinished);
        return context;
    }
    /**
     * Converts a token from query request to a type used in persistence
     * layer query function.
     *
     * @private
     * @static
     * @param {string} token
     * @return {*}  {string}
     * @memberof LokiTableMetadataStore
     */
    convertOperatorToken(token) {
        switch (token) {
            case "and":
                return "&&";
            case "or":
                return "||";
            case "not":
                return "!";
            default:
                return token;
        }
    }
    /**
     * Stores the tokens
     *
     * @private
     * @param {QueryContext} context
     * @param {string} token
     * @param {number} originalTokenLength
     * @return {*}  {QueryContext}
     * @memberof StateProcessPredicateOperator
     */
    storeTaggedTokens(context, token, originalTokenLength) {
        // predicate operator should be stored singly
        const taggedToken = new TaggedToken_1.default(token, new OperatorToken_1.default());
        context.taggedPredicates.push(new PredicateOperator_1.default(new TokenMap_1.TokenMap([taggedToken])));
        context.currentPredicate += 1;
        context.currentPos += originalTokenLength;
        return context;
    }
    /**
     * Starts a new predicate in case we are working without parens
     *
     * @param {QueryContext} context
     * @return {*}  {QueryContext}
     * @memberof StateProcessPredicateOperator
     */
    incrementPredicateWithoutParens(context) {
        if (context.taggedPredicates[this.getCorrectPredicate(context)].tokenMap
            .tokens.length === 3) {
            context.currentPredicate += 1;
            context.taggedPredicates.push(new UnknownPredicate_1.default(new TokenMap_1.TokenMap([])));
            return context;
        }
        this.checkNumberOfTokens(context);
        return context;
    }
    /**
     * Get's the correct predic ate number, depending on if we have parens or not
     *
     * @param {QueryContext} context
     * @return {*}
     * @memberof StateProcessPredicateOperator
     */
    getCorrectPredicate(context) {
        if (context.taggedPredicates[context.currentPredicate] === undefined) {
            return context.currentPredicate - 1; // why is this 2?
        }
        else {
            return context.currentPredicate;
        }
    }
    /**
     * Ensures that predicate is valid based on number of tokens
     *
     * @param {QueryContext} context
     * @memberof StateProcessPredicateOperator
     */
    checkNumberOfTokens(context) {
        if (context.taggedPredicates[this.getCorrectPredicate(context)].tokenMap
            .tokens.length !== 1) {
            throw new Error("Invalid number of tokens in predicate.");
        }
    }
}
exports.default = StateProcessPredicateOperator;
//# sourceMappingURL=StateProcessPredicateOperator.js.map