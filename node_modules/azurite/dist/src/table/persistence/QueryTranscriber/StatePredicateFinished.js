"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const QPState_1 = tslib_1.__importDefault(require("./QPState"));
const QueryStateName_1 = require("./QueryStateName");
const GuidPredicate_1 = tslib_1.__importDefault(require("./PredicateModel/GuidPredicate"));
const BinaryPredicate_1 = tslib_1.__importDefault(require("./PredicateModel/BinaryPredicate"));
const LongPredicate_1 = tslib_1.__importDefault(require("./PredicateModel/LongPredicate"));
const DoublePredicate_1 = tslib_1.__importDefault(require("./PredicateModel/DoublePredicate"));
const IntegerPredicate_1 = tslib_1.__importDefault(require("./PredicateModel/IntegerPredicate"));
const StringPredicate_1 = tslib_1.__importDefault(require("./PredicateModel/StringPredicate"));
const DatePredicate_1 = tslib_1.__importDefault(require("./PredicateModel/DatePredicate"));
const BooleanPredicate_1 = tslib_1.__importDefault(require("./PredicateModel/BooleanPredicate"));
/**
 * contains the logic for checking a predicate when it is finished
 *
 * @export
 * @class StatePredicateFinished
 * @extends {QPState}
 * @implements {IQPState}
 */
class StatePredicateFinished extends QPState_1.default {
    constructor() {
        super(...arguments);
        this.name = QueryStateName_1.QueryStateName.PredicateFinished;
        /**
         * when finishing a predicate, we need to update the query type
         * based on the value being queried
         *
         * @param {QueryContext} context
         * @memberof StatePredicateFinished
         */
        this.onProcess = (context) => {
            let token = "";
            // when first predicate is a single operator, our token map is empty
            context = this.validatePredicate(context);
            [context, token] = this.getNextToken(context);
            context = this.handleToken(context, token);
            return context;
        };
        /**
         * optional post processing, here we can add logging
         * or additional validation etc
         *
         * @param {QueryContext} context
         * @memberof StateProcessValue
         */
        this.onExit = (context) => {
            // ToDo: validate current predicate early or during transcribing?
            // might even be able to remove the onExit hooks.
            return context;
        };
    }
    /**
     * state transition logic
     *
     * @protected
     * @param {QueryContext} context
     * @param {string} token
     * @return {*}  {QueryContext}
     * @memberof StatePredicateFinished
     */
    handleToken(context, token) {
        // categorize the token
        if (token === "") {
            context.stateQueue.push(QueryStateName_1.QueryStateName.QueryFinished);
        }
        else if (token === "(") {
            context.stateQueue.push(QueryStateName_1.QueryStateName.PredicateStarted);
        }
        else if (token === ")") {
            context.stateQueue.push(QueryStateName_1.QueryStateName.ProcessParensClose);
        }
        else if (this.isPredicateOperator(token)) {
            context.stateQueue.push(QueryStateName_1.QueryStateName.ProcessPredicateOperator);
            // will need to end current predicate and create a new predicate
        }
        else if (this.isOperand(token)) {
            // match operand (specific set)
            throw new Error("Invalid Query, unable to process operand starting predicate!");
        }
        else if (this.isValue(token)) {
            // match number (long & doubles? needed)
            // match string (starts with ', or " ?)
            // match guid (is exactly guid'<guidval>')
            context.stateQueue.push(QueryStateName_1.QueryStateName.PredicateStarted);
        }
        else if (this.isIdentifier(token)) {
            // match identifier (can only start with letter)
            context.stateQueue.push(QueryStateName_1.QueryStateName.PredicateStarted);
        }
        return context;
    }
    /**
     * validates the predicate using some simple logic
     * ToDo: ensure correct error codes!!!
     *
     * @param {QueryContext} context
     * @return {*}  {QueryContext}
     * @memberof StatePredicateFinished
     */
    validatePredicate(context) {
        const predicateOffset = this.getPredicateOffsetToCheck(context);
        this.checkPredicateLength(predicateOffset, context);
        this.checkSingleTerm(predicateOffset, context);
        this.checkMultipleTerms(predicateOffset, context);
        context = this.setPredicateType(context);
        return context;
    }
    getPredicateOffsetToCheck(context) {
        return context.currentPredicate > 0 ? context.currentPredicate - 1 : 0;
    }
    /**
     * tags the predicate based on the type of value found in the
     * predicate terms
     *
     * @param {QueryContext} context
     * @return {*}  {QueryContext}
     * @memberof StatePredicateFinished
     */
    setPredicateType(context) {
        if (context.taggedPredicates[context.currentPredicate] === undefined) {
            return context;
        }
        const taggedTokens = context.taggedPredicates[context.currentPredicate].tokenMap.tokens;
        taggedTokens.forEach((taggedToken) => {
            if (taggedToken.type.isValue()) {
                context = this.ifGuidPredicate(context, taggedToken.token);
                context = this.ifBinaryPredicate(context, taggedToken.token);
                context = this.ifLongPredicate(context, taggedToken.token);
                context = this.ifDoublePredicate(context, taggedToken.token);
                context = this.ifIntegerPredicate(context, taggedToken.token);
                context = this.ifStringPredicate(context, taggedToken.token);
                context = this.ifDatePredicate(context, taggedToken.token);
                context = this.ifBooleanPredicate(context, taggedToken.token);
            }
        });
        return context;
    }
    /**
     * tags predicate for the case of a guid predicate
     *
     * @param {QueryContext} context
     * @param {string} tokenToCheck
     * @return {*}  {QueryContext}
     * @memberof StatePredicateFinished
     */
    ifGuidPredicate(context, tokenToCheck) {
        if (this.isGuidValue(tokenToCheck)) {
            context.taggedPredicates[context.currentPredicate] = new GuidPredicate_1.default(context.taggedPredicates[context.currentPredicate].tokenMap);
            return context;
        }
        return context;
    }
    /**
     * tags predicate for the case of a binary value
     *
     * @param {QueryContext} context
     * @param {string} tokenToCheck
     * @return {*}  {QueryContext}
     * @memberof StatePredicateFinished
     */
    ifBinaryPredicate(context, tokenToCheck) {
        if (this.isBinaryValue(tokenToCheck)) {
            context.taggedPredicates[context.currentPredicate] = new BinaryPredicate_1.default(context.taggedPredicates[context.currentPredicate].tokenMap);
            return context;
        }
        return context;
    }
    /**
     * tags predicate for the case of a long value
     *
     * @param {QueryContext} context
     * @param {string} tokenToCheck
     * @return {*}  {QueryContext}
     * @memberof StatePredicateFinished
     */
    ifLongPredicate(context, tokenToCheck) {
        if (this.isLongValue(tokenToCheck)) {
            context.taggedPredicates[context.currentPredicate] = new LongPredicate_1.default(context.taggedPredicates[context.currentPredicate].tokenMap);
            return context;
        }
        return context;
    }
    /**
     * tags predicate for the case of a double value
     *
     * @param {QueryContext} context
     * @param {string} tokenToCheck
     * @return {*}  {QueryContext}
     * @memberof StatePredicateFinished
     */
    ifDoublePredicate(context, tokenToCheck) {
        if (this.isDoubleValue(tokenToCheck)) {
            context.taggedPredicates[context.currentPredicate] = new DoublePredicate_1.default(context.taggedPredicates[context.currentPredicate].tokenMap);
            return context;
        }
        return context;
    }
    /**
     * tags predicate for the case of an integer value
     *
     * @param {QueryContext} context
     * @param {string} tokenToCheck
     * @return {*}  {QueryContext}
     * @memberof StatePredicateFinished
     */
    ifIntegerPredicate(context, tokenToCheck) {
        if (this.isIntegerValue(tokenToCheck)) {
            context.taggedPredicates[context.currentPredicate] = new IntegerPredicate_1.default(context.taggedPredicates[context.currentPredicate].tokenMap);
            return context;
        }
        return context;
    }
    /**
     * tags predicate for the case of a string value
     *
     * @param {QueryContext} context
     * @param {string} tokenToCheck
     * @return {*}  {QueryContext}
     * @memberof StatePredicateFinished
     */
    ifStringPredicate(context, tokenToCheck) {
        if (this.isStringValue(tokenToCheck)) {
            context.taggedPredicates[context.currentPredicate] = new StringPredicate_1.default(context.taggedPredicates[context.currentPredicate].tokenMap);
            return context;
        }
        return context;
    }
    /**
     * tags predicate for the case of a date value
     *
     * @param {QueryContext} context
     * @param {string} tokenToCheck
     * @return {*}  {QueryContext}
     * @memberof StatePredicateFinished
     */
    ifDatePredicate(context, tokenToCheck) {
        if (this.isDateValue(tokenToCheck)) {
            context.taggedPredicates[context.currentPredicate] = new DatePredicate_1.default(context.taggedPredicates[context.currentPredicate].tokenMap);
            return context;
        }
        return context;
    }
    /**
     * tags predicate for the case of a boolean value
     *
     * @param {QueryContext} context
     * @param {string} tokenToCheck
     * @return {*}  {QueryContext}
     * @memberof StatePredicateFinished
     */
    ifBooleanPredicate(context, tokenToCheck) {
        if (this.isBooleanValue(tokenToCheck)) {
            context.taggedPredicates[context.currentPredicate] = new BooleanPredicate_1.default(context.taggedPredicates[context.currentPredicate].tokenMap);
            return context;
        }
        return context;
    }
    /**
     * checks the number of terms in a predicate based on the state
     * machines own logic (1 or 3 terms)
     *
     * @private
     * @param {QueryContext} context
     * @memberof StatePredicateFinished
     */
    checkPredicateLength(offset, context) {
        if (context.taggedPredicates[offset].tokenMap.tokens.length !== 1 &&
            context.taggedPredicates[offset].tokenMap.tokens.length !== 3) {
            // we must have form "x operator b", or a single value
            throw new Error("Invalid Query");
        }
    }
    /**
     * checks a single term
     *
     * @private
     * @param {QueryContext} context
     * @return {*}
     * @memberof StatePredicateFinished
     */
    checkSingleTerm(offset, context) {
        if (context.taggedPredicates[offset].tokenMap.tokens.length === 1) {
            // we must have a parens or a single value
            // ToDo: validate this logic has parity with Azure service
            // This checks that a single tagged token is of a type allowed to be
            // on it's own in a predicate;
            const predicateType = context.taggedPredicates[offset].tokenMap.tokens[0].type;
            const predicateValue = context.taggedPredicates[offset].tokenMap.tokens[0].token;
            if (predicateType.isParensOpen() ||
                predicateType.isParensClose() ||
                predicateType.isOperator() ||
                (predicateType.isValue() && this.isBooleanValue(predicateValue))) {
                return;
            }
            throw new Error("Invalid Query");
        }
    }
    /**
     * checks multiple terms
     *
     * @private
     * @param {QueryContext} context
     * @memberof StatePredicateFinished
     */
    checkMultipleTerms(offset, context) {
        if (context.taggedPredicates[offset].tokenMap.tokens.length === 3) {
            // we must have form "x operator b"
            this.checkNumberOfValues(offset, context);
            this.checkNumberOfOperators(offset, context);
            this.checkNumberOfIdentifiers(offset, context);
        }
    }
    /**
     * Checks that there is only 1 value in the predicate
     *
     * @private
     * @param {number} offset
     * @param {QueryContext} context
     * @memberof StatePredicateFinished
     */
    checkNumberOfValues(offset, context) {
        let valueCount = 0;
        context.taggedPredicates[offset].tokenMap.tokens.forEach((taggedToken) => {
            if (taggedToken.type.isValue()) {
                valueCount++;
            }
        });
        this.checkPredicateTermCount(valueCount);
    }
    /**
     * Checks that there is only 1 identifier in the predicate
     *
     * @private
     * @param {number} offset
     * @param {QueryContext} context
     * @memberof StatePredicateFinished
     */
    checkNumberOfIdentifiers(offset, context) {
        let valueCount = 0;
        context.taggedPredicates[offset].tokenMap.tokens.forEach((taggedToken) => {
            if (taggedToken.type.isIdentifier()) {
                valueCount++;
            }
        });
        this.checkPredicateTermCount(valueCount);
    }
    /**
     * Checks that there is only 1 operator in the predicate
     *
     * @private
     * @param {number} offset
     * @param {QueryContext} context
     * @memberof StatePredicateFinished
     */
    checkNumberOfOperators(offset, context) {
        let valueCount = 0;
        context.taggedPredicates[offset].tokenMap.tokens.forEach((taggedToken) => {
            if (taggedToken.type.isOperator()) {
                valueCount++;
            }
        });
        this.checkPredicateTermCount(valueCount);
    }
    /**
     * checks that there is only 1 of this type of term
     *
     * @private
     * @param {number} count
     * @memberof StatePredicateFinished
     */
    checkPredicateTermCount(count) {
        if (count !== 1) {
            throw new Error("Invalid number of terms in query!");
        }
    }
}
exports.default = StatePredicateFinished;
//# sourceMappingURL=StatePredicateFinished.js.map